(* Generated by Frama-C WP *)

Goal typed_lemma_sum_only_read.
Hint property,sum_only_read.
Proof.
  intros. revert dependent i.
  apply (natlike_ind (fun i => i <= i_1 -> L_sum t_1 a_1 a i_3 i_2 i_1 i = L_sum t a_1 a i_3 i_2 i_1 i));
    intros.
  - rewrite 2!A_sum_axiomatic.Q_sum_nil. reflexivity.
  - intros. replace (Z.succ x) with (1+x) by ring.
    rewrite <- 2!A_sum_axiomatic.Q_sum_next.
    rewrite H1 by omega. f_equal.
    f_equal.
    apply H6.
    assert (0<=x*i_1) by (apply Z.mul_nonneg_nonneg; assumption).
    omega.
    eapply Z.lt_le_trans.
    apply Zplus_lt_compat_r. apply H3.
    replace (i_1 + x * i_1) with ((x+1)*i_1) by ring.
    apply Zmult_le_compat_r.
    omega. omega.
    apply H6.
    assert (0<=i_1*i_3) by (apply Z.mul_nonneg_nonneg; assumption).
    omega.
    eapply Z.lt_le_trans.
    apply Zplus_lt_compat_r. assert (x < i_1) by omega. apply H8.
    replace (i_1 + i_1 * i_3) with ((i_3+1)*i_1) by ring.
    apply Zmult_le_compat_r.
    omega. omega.
Qed.

Goal typed_matrix_mult_loop_assign_part3.
Hint *,c,i,loop-assigns,matrix_mult,part-2.
Proof.
  intros.
  unfold a_6, a_3.
  repeat split; simpl; Psatz.nia.
Qed.

Goal typed_matrix_mult_loop_assign_part4.
Hint *,c,i,loop-assigns,matrix_mult,part-3.
Proof.
  intros.
  unfold a_6, a_3.
  repeat split; simpl; Psatz.nia.
Qed.

Goal typed_matrix_mult_loop_inv_2_preserved.
Hint matrix_mult,preserved.
Proof.
  intros.
  assert (i = i_1) by omega. subst i_1.
  apply Zle_lt_or_eq in H6.
  destruct H6.
  - replace (L_sum t_3 a_2 a_1 i_4 i_3 i i) with (L_sum t_2 a_2 a_1 i_4 i_3 i i).
    rewrite <- H26 by omega.
    replace (i_4*i) with (i*i_4) by ring.
    symmetry.
    apply H24.
    do 4 right. simpl. unfold x_1. Psatz.nia.
    apply Axiomatic1.Q_sum_only_read; try Psatz.nia.
    intros. split.
    + unfold a_0. apply H24. unfold separated in H21.
      decompose [or] H21. unfold x in H29. Psatz.nia.
      unfold x in H30. Psatz.nia. simpl in H29.
      do 2 right; left. simpl. assumption.
      unfold x in H30; simpl in H30. unfold x_1. do 3 right. simpl. Psatz.nia.
      do 4 right. unfold x_1. simpl. unfold x in H30. simpl in H30. Psatz.nia.
    + unfold a_6. apply H24. unfold separated in H22.
      decompose [or] H22. unfold x in H29. Psatz.nia.
      unfold x in H30. Psatz.nia. simpl in H29.
      do 2 right; left. simpl. assumption.
      unfold x in H30; simpl in H30. unfold x_1. do 3 right. simpl. Psatz.nia.
      do 4 right. unfold x_1. simpl. unfold x in H30. simpl in H30. Psatz.nia.
  - subst i_4.
    apply H25; omega.
Qed.

Goal typed_matrix_mult_loop_inv_3_preserved.
Hint matrix_mult,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_matrix_mult_loop_inv_4_preserved.
Hint matrix_mult,preserved.
Proof.
  intros.
  assert (i_1 = i_2) by omega. subst i_2.
  apply Zle_lt_or_eq in H8.
  destruct H8.
  - 

  unfold m. unfold x in H29. rewrite access_update_neq. rewrite H29.
  symmetry.
  erewrite Axiomatic1.Q_sum_only_read. reflexivity.
  omega. omega. omega. omega. omega. omega. omega.
  intros.
  split.
  + rewrite access_update_neq. reflexivity.
    unfold x_2. unfold a_0. intros contra. inversion contra.
    unfold separated in H25. decompose [or] H25.
    unfold x_1 in H33. Psatz.nia.
    unfold x_1 in H36. Psatz.nia.
    unfold a_3, a_5 in H33. simpl in H33. Psatz.nia.
    unfold a_5, x_1 in H36. simpl in H36. Psatz.nia.
    unfold a_5, x_1 in H36. simpl in H36. Psatz.nia.
  + rewrite access_update_neq. reflexivity.
    unfold x_2, a_6. intros contra. inversion contra.
    unfold separated in H26. decompose [or] H26.
    unfold x_1 in H33. Psatz.nia.
    unfold x_1 in H36. Psatz.nia.
    unfold a_4, a_5 in H33. simpl in H33. Psatz.nia.
    unfold x_1 in H36. simpl in H36. Psatz.nia.
    unfold x_1 in H36. simpl in H36. Psatz.nia.
  + omega.
  + assumption.
  + unfold x_2. intros contra. inversion contra. Psatz.nia.
  - subst i_4. unfold m. rewrite access_update. rewrite <- H at 1.
    erewrite Axiomatic1.Q_sum_only_read.
    symmetry. erewrite Axiomatic1.Q_sum_only_read. reflexivity.
  all: try omega.
  intros.
  split.
  + rewrite access_update_neq. reflexivity.
    unfold x_2. unfold a_0. intros contra. inversion contra.
    unfold separated in H25. decompose [or] H25.
    unfold x_1 in H32. Psatz.nia.
    unfold x_1 in H35. Psatz.nia.
    unfold a_3, a_5 in H32. simpl in H32. Psatz.nia.
    unfold a_5, x_1 in H35. simpl in H35. Psatz.nia.
    unfold a_5, x_1 in H35. simpl in H35. Psatz.nia.
  + rewrite access_update_neq. reflexivity.
    unfold x_2, a_6. intros contra. inversion contra.
    unfold separated in H26. decompose [or] H26.
    unfold x_1 in H32. Psatz.nia.
    unfold x_1 in H35. Psatz.nia.
    unfold a_4, a_5 in H32. simpl in H32. Psatz.nia.
    unfold x_1 in H35. simpl in H35. Psatz.nia.
    unfold x_1 in H35. simpl in H35. Psatz.nia.
  + intros.
  split.
  * rewrite access_update_neq. reflexivity.
    unfold x. unfold a_0. intros contra. inversion contra.
    unfold separated in H25. decompose [or] H25.
    unfold x_1 in H32. Psatz.nia.
    unfold x_1 in H35. Psatz.nia.
    unfold a_3, a_5 in H32. simpl in H32. Psatz.nia.
    unfold a_5, x_1 in H35. simpl in H35. Psatz.nia.
    unfold a_5, x_1 in H35. simpl in H35. Psatz.nia.
  * rewrite access_update_neq. reflexivity.
    unfold x, a_6. intros contra. inversion contra.
    unfold separated in H26. decompose [or] H26.
    unfold x_1 in H32. Psatz.nia.
    unfold x_1 in H35. Psatz.nia.
    unfold a_4, a_5 in H32. simpl in H32. Psatz.nia.
    unfold x_1 in H35. simpl in H35. Psatz.nia.
    unfold x_1 in H35. simpl in H35. Psatz.nia.
Qed.

Goal typed_matrix_mult_loop_inv_5_preserved.
Hint matrix_mult,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_matrix_mult_loop_inv_6_established.
Hint established,matrix_mult.
Proof.
  intros. rewrite access_update_neq.
  rewrite <- H25. symmetry. replace (i_3*i) with (i*i_3) by ring. apply H23.
  unfold separated.
  do 4 right. simpl. unfold x_1. Psatz.nia. omega. omega. omega. omega.
  intros contra. inversion contra. unfold x_1 in H27. Psatz.nia.
Qed.

Goal typed_matrix_mult_loop_inv_6_preserved.
Hint matrix_mult,preserved.
Proof.
  intros.
  unfold x_5, x_4, x_3, x_2, x_1, x. rewrite <- H.
  erewrite Axiomatic1.Q_sum_only_read with (t_1:=t_3.[_<-_]); try Psatz.nia.
  rewrite <- A_sum_axiomatic.Q_sum_next. f_equal.
  replace (i_1 * i_2) with (i_2*i_1) by ring. reflexivity.
  intros. split.
  - unfold m. rewrite !access_update_neq. reflexivity.
    intros contra. unfold a_3, a_0, x in contra. inversion contra.
    unfold separated in H23.
    decompose [or] H23. unfold x_2 in H34. Psatz.nia.
    unfold x_2 in H37. Psatz.nia. unfold a_5, a_6 in H34. simpl in H34. Psatz.nia.
    unfold x_2 in H37. unfold a_6, a_4 in H37. simpl in H37.
    Psatz.nia.
    unfold x_2 in H37. unfold a_6, a_4 in H37. simpl in H37.
    Psatz.nia.

intros contra. unfold a_3, a_0, x in contra. inversion contra.
    unfold separated in H23.
    decompose [or] H23. unfold x_2 in H34. Psatz.nia.
    unfold x_2 in H37. Psatz.nia. unfold a_5, a_6 in H34. simpl in H34. Psatz.nia.
    unfold x_2 in H37. unfold a_6, a_4 in H37. simpl in H37.
    Psatz.nia.
    unfold x_2 in H37. unfold a_6, a_4 in H37. simpl in H37.
    Psatz.nia.
  - unfold m. rewrite !access_update_neq. reflexivity.
intros contra. unfold a_3, a_7, x in contra. inversion contra.
    unfold separated in H24.
    decompose [or] H24. unfold x_2 in H34. Psatz.nia.
    unfold x_2 in H37. Psatz.nia. unfold a_5, a_6 in H34. simpl in H34. Psatz.nia.
    unfold x_2 in H37. unfold a_6, a_4 in H37. simpl in H37.
    Psatz.nia.
    unfold x_2 in H37. unfold a_6, a_4 in H37. simpl in H37.
    Psatz.nia.
intros contra. unfold a_3, a_7, x in contra. inversion contra.
    unfold separated in H24.
    decompose [or] H24. unfold x_2 in H34. Psatz.nia.
    unfold x_2 in H37. Psatz.nia. unfold a_5, a_6 in H34. simpl in H34. Psatz.nia.
    unfold x_2 in H37. unfold a_6, a_4 in H37. simpl in H37.
    Psatz.nia.
    unfold x_2 in H37. unfold a_6, a_4 in H37. simpl in H37.
    Psatz.nia.
Qed.

Goal typed_matrix_mult_loop_inv_8_preserved.
Hint matrix_mult,preserved.
Proof.
  intros.
  unfold x_5, x_4, x_3, x_2, x_1, x.
  erewrite <- A_sum_axiomatic.Q_sum_next.
  f_equal. rewrite <- H.
  assert (forall x, i_2 < i_1 -> L_sum m a_2 a_1 i_4 i_3 i_1 i_2 = L_sum
  (t_3 .[ a_3 <-x ]) a_2 a_1 i_4 i_3
  i_1 i_2).
  { apply (natlike_ind (fun i_2 => forall x0 : int,
i_2 < i_1 -> L_sum m a_2 a_1 i_4 i_3 i_1 i_2 = L_sum (t_3 .[ a_3 <- x0]) a_2 a_1 i_4 i_3 i_1 i_2));
     intros.
    - rewrite 2!A_sum_axiomatic.Q_sum_nil. reflexivity.
    - replace (Z.succ x0) with (1+x0) by ring.
      rewrite <- 2!A_sum_axiomatic.Q_sum_next.
      f_equal.
      apply H35. omega.
      unfold m.
      rewrite 4!access_update_neq. reflexivity. (* 
      unfold a_3, x. intros contra. inversion contra.
      Psatz.nia. *)
      eapply separated_1. apply separated_sym.
      assert (a = a_6).
      { unfold a_6. unfold shift_sint32, shift. replace (offset a+0) with (offset a) by ring.
        destruct a; reflexivity.
      }
      assert (a_2 = a_5).
      { unfold a_5. unfold shift_sint32, shift. replace (offset a_2+0) with (offset a_2) by ring.
        destruct a_2; reflexivity.
      }
      rewrite <- H37, <- H38 in *.
      eassumption.
      unfold x, x_2. Psatz.nia. 
      unfold x_2. Psatz.nia.
      eapply separated_1. apply separated_sym.
      assert (a = a_6).
      { unfold a_6. unfold shift_sint32, shift. replace (offset a+0) with (offset a) by ring.
        destruct a; reflexivity.
      }
      assert (a_1 = a_4).
      { unfold a_4. unfold shift_sint32, shift. replace (offset a_1+0) with (offset a_1) by ring.
        destruct a_1; reflexivity.
      }
      rewrite <- H37, <- H38 in *.
      eassumption.
      unfold x, x_2. Psatz.nia. 
      unfold x_2. Psatz.nia.

     eapply separated_1. apply separated_sym.
      assert (a = a_6).
      { unfold a_6. unfold shift_sint32, shift. replace (offset a+0) with (offset a) by ring.
        destruct a; reflexivity.
      }
      assert (a_2 = a_5).
      { unfold a_5. unfold shift_sint32, shift. replace (offset a_2+0) with (offset a_2) by ring.
        destruct a_2; reflexivity.
      }
      rewrite <- H37, <- H38 in *.
      eassumption.
      unfold x, x_2. Psatz.nia. 
      unfold x_2. Psatz.nia.
      eapply separated_1. apply separated_sym.
      assert (a = a_6).
      { unfold a_6. unfold shift_sint32, shift. replace (offset a+0) with (offset a) by ring.
        destruct a; reflexivity.
      }
      assert (a_1 = a_4).
      { unfold a_4. unfold shift_sint32, shift. replace (offset a_1+0) with (offset a_1) by ring.
        destruct a_1; reflexivity.
      }
      rewrite <- H37, <- H38 in *.
      eassumption.
      unfold x, x_2. Psatz.nia. 
      unfold x_2. Psatz.nia.
  - omega. }
  rewrite <- H34. reflexivity.
   omega.
  unfold m. rewrite !access_update_neq. replace (i_1*i_2) with (i_2*i_1) by ring.
  reflexivity.
  eapply separated_1. apply separated_sym.
      assert (a = a_6).
      { unfold a_6. unfold shift_sint32, shift. replace (offset a+0) with (offset a) by ring.
        destruct a; reflexivity.
      }
      assert (a_2 = a_5).
      { unfold a_5. unfold shift_sint32, shift. replace (offset a_2+0) with (offset a_2) by ring.
        destruct a_2; reflexivity.
      }
      rewrite <- H34, <- H35 in *.
      eassumption.
      unfold x, x_2. Psatz.nia. 
      unfold x_2. Psatz.nia.
      eapply separated_1. apply separated_sym.
      assert (a = a_6).
      { unfold a_6. unfold shift_sint32, shift. replace (offset a+0) with (offset a) by ring.
        destruct a; reflexivity.
      }
      assert (a_1 = a_4).
      { unfold a_4. unfold shift_sint32, shift. replace (offset a_1+0) with (offset a_1) by ring.
        destruct a_1; reflexivity.
      }
      rewrite <- H34, <- H35 in *.
      eassumption.
      unfold x, x_2. Psatz.nia. 
      unfold x_2. Psatz.nia.

     eapply separated_1. apply separated_sym.
      assert (a = a_6).
      { unfold a_6. unfold shift_sint32, shift. replace (offset a+0) with (offset a) by ring.
        destruct a; reflexivity.
      }
      assert (a_2 = a_5).
      { unfold a_5. unfold shift_sint32, shift. replace (offset a_2+0) with (offset a_2) by ring.
        destruct a_2; reflexivity.
      }
      rewrite <- H34, <- H35 in *.
      eassumption.
      unfold x, x_2. Psatz.nia. 
      unfold x_2. Psatz.nia.
      eapply separated_1. apply separated_sym.
      assert (a = a_6).
      { unfold a_6. unfold shift_sint32, shift. replace (offset a+0) with (offset a) by ring.
        destruct a; reflexivity.
      }
      assert (a_1 = a_4).
      { unfold a_4. unfold shift_sint32, shift. replace (offset a_1+0) with (offset a_1) by ring.
        destruct a_1; reflexivity.
      }
      rewrite <- H34, <- H35 in *.
      eassumption.
      unfold x, x_2. Psatz.nia. 
      unfold x_2. Psatz.nia.
Qed.

Goal typed_matrix_mult_loop_inv_preserved.
Hint matrix_mult,preserved.
Proof.
  auto with zarith.
Qed.


