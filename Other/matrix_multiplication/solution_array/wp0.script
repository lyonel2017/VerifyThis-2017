(* Generated by Frama-C WP *)

Goal typed_driver_lemma_sum_assoc.
Hint property,sum_assoc.
Proof.
(* --------------------------------------
  
From 'typed_lemma_sum_assoc': 
(* auto with zarith. *)
*)
Qed.

Goal typed_driver_lemma_testt.
Hint property,testt.
Proof.
(* auto with zarith. *)
Qed.

Goal typed_lemma_sum_assoc.
Hint property,sum_assoc.
Proof.
  assert (forall t a b n i j,
    0 <= n -> 0 <= i -> 0 <= j ->
    multZ (fun i j => t.[shift_sint32 a (i*n+j)])
         (fun i j => t.[shift_sint32 b (i*n+j)])
         n i j = L_sum t a b n i j n)
  as Ha.
  { intros. revert H.
    apply (natlike_ind (fun k =>
    multZ (fun i0 j0 : int => t .[ shift_sint32 a (i0 * n + j0)])
  (fun i0 j0 : int => t .[ shift_sint32 b (i0 * n + j0)]) k i j = L_sum t a b n i j k)).
    - unfold multZ, mult; simpl. rewrite A_sum_axiomatic.Q_sum_nil. reflexivity.
    - intros k H2 H3. unfold multZ, mult.
      replace (Z.to_nat (Z.succ k)) with (S (Z.to_nat k)). simpl sum.
      replace (Z.succ k) with (1+k) by ring.
      rewrite <- A_sum_axiomatic.Q_sum_next.
      rewrite <- H3. f_equal.
      rewrite !Z2Nat.id by omega.
      rewrite Z.mul_comm. repeat (ring || f_equal).
      symmetry. apply Z2Nat.inj_succ; omega.
  }
  intros.
  rewrite <- Ha by omega.
  erewrite multZ_extensionality; try omega.
  rewrite <- multZ_assoc by omega.
  erewrite multZ_extensionality; try omega.
  rewrite Ha by omega. reflexivity.
  - intros. simpl. rewrite Z.add_comm. rewrite H by omega.
    apply Ha; omega.
  - intros. simpl. reflexivity.
  - intros. simpl. reflexivity.
  - intros. rewrite Z.add_comm. rewrite H0 by omega.
    symmetry. apply Ha; omega.
Qed.

Goal typed_lemma_sum_only_read.
Hint property,sum_only_read.
Proof.
  intros.
  revert dependent i.
  apply (natlike_ind (fun i => i <= i_3 -> L_sum t_1 a_1 a i_3 i_2 i_1 i = L_sum t a_1 a i_3 i_2 i_1 i));
    intros.
  - rewrite 2!A_sum_axiomatic.Q_sum_nil. reflexivity.
  - intros. replace (Z.succ x) with (1+x) by ring.
    rewrite <- 2!A_sum_axiomatic.Q_sum_next.
    rewrite H5 by omega. f_equal.
    f_equal.
    + symmetry. apply H6; Psatz.nia.
    + symmetry. apply H7; Psatz.nia.
Qed.

Goal typed_matrix_mult_assoc_assert.
Hint matrix_mult_assoc,property.
Proof.
  intros. symmetry.
  apply H40.
  eapply separated_trans; [|apply separated_sym; eassumption].
  repeat split; simpl; unfold x; Psatz.nia.
Qed.

Goal typed_matrix_mult_assoc_assert_2.
Hint matrix_mult_assoc,property.
Proof.
  intros. symmetry.
  apply H40.
  eapply separated_trans; [|apply separated_sym; eassumption].
  repeat split; simpl; unfold x; Psatz.nia.
Qed.

Goal typed_matrix_mult_assoc_assert_29.
Hint matrix_mult_assoc,property.
Proof.
(* --------------------------------------
  
From 'typed_matrix_mult_assoc_assert_2': 
  intros. symmetry.
  apply H40.
  eapply separated_trans; [|apply separated_sym; eassumption].
  repeat split; simpl; unfold x; Psatz.nia.
*)
(* --------------------------------------
  
From 'typed_matrix_mult_assoc_assert_8': 
  intros.
  unfold x_1.
  rewrite Z.mul_comm.
  rewrite H56, H54 by omega.
  eapply Axiomatic1.Q_sum_assoc; try omega; eauto.
*)
(* --------------------------------------
  
From 'typed_matrix_mult_assoc_assert_5': 
(* auto with zarith. *)
*)
Qed.

Goal typed_matrix_mult_assoc_assert_3.
Hint matrix_mult_assoc,property.
Proof.
  intros. symmetry.
  unfold a_14. rewrite Z.mul_comm.
  rewrite <- H45 by omega.
  apply H43.
  eapply separated_trans; [|apply separated_sym; eassumption].
  repeat split; simpl; unfold x; Psatz.nia.
Qed.

Goal typed_matrix_mult_assoc_assert_4.
Hint matrix_mult_assoc,property.
Proof.
  intros.
  replace (t_5 .[ shift_sint32 a_4 (i_1 + i * i_2)])
     with (t_4 .[ shift_sint32 a_4 (i_1 + i * i_2)]).
  replace (t_4 .[ shift_sint32 a_4 (i_1 + i * i_2)])
     with (t_3 .[ shift_sint32 a_4 (i_1 + i * i_2)]).
  replace (t_3 .[ shift_sint32 a_4 (i_1 + i * i_2)])
     with (t_2 .[ shift_sint32 a_4 (i_1 + i * i_2)]).
  rewrite Z.mul_comm.
  rewrite H50 by omega.
  apply Axiomatic1.Q_sum_only_read; try omega.
  unfold P_matrix_eq; intros.
  transitivity (t_4 .[ shift_sint32 a_2 i0]).
  symmetry. apply H49. eapply separated_trans.
  2: apply separated_sym.
  2:apply H42.
  repeat split. unfold x. omega. simpl; omega. simpl. unfold x; omega.
  transitivity (t_3 .[ shift_sint32 a_2 i0]).
  symmetry. apply H48. eapply separated_trans.
  2: apply separated_sym.
  2:apply H25.
  repeat split. unfold x. omega. simpl; omega. simpl. unfold x; omega.
  symmetry. apply H47. eapply separated_trans.
  2: apply separated_sym.
  2:apply H32.
  repeat split. unfold x. omega. simpl; omega. simpl. unfold x; omega.
  unfold P_matrix_eq; intros.
  transitivity (t_4 .[ shift_sint32 a_6 i0]).
  symmetry. apply H49. eapply separated_trans.
  2: apply separated_sym.
  2:apply H43.
  repeat split. unfold x. omega. simpl; omega. simpl. unfold x; omega.
  transitivity (t_3 .[ shift_sint32 a_6 i0]).
  symmetry. apply H48. eapply separated_trans.
  2: apply separated_sym.
  2:apply H28.
  repeat split. unfold x. omega. simpl; omega. simpl. unfold x; omega.
  symmetry. apply H47. eapply separated_trans.
  2: apply separated_sym.
  2:apply H34.
  repeat split. unfold x. omega. simpl; omega. simpl. unfold x; omega.
  apply H47. eapply separated_trans.
  2:apply H38.
  repeat split. unfold x. Psatz.nia. simpl; Psatz.nia. simpl.
  unfold x; Psatz.nia.
  apply H48. eapply separated_trans.
  2:apply H36.
  repeat split. unfold x. Psatz.nia. simpl; Psatz.nia. simpl.
  unfold x; Psatz.nia.
  apply H49. eapply separated_trans.
  2:apply H39.
  repeat split. unfold x. Psatz.nia. simpl; Psatz.nia. simpl.
  unfold x; Psatz.nia.
Qed.

Goal typed_matrix_mult_assoc_assert_5.
Hint matrix_mult_assoc,property.
Proof.
(* auto with zarith. *)
Qed.

Goal typed_matrix_mult_assoc_assert_6.
Hint matrix_mult_assoc,property.
Proof.
  intros. symmetry. unfold a_14. rewrite Z.mul_comm.
  rewrite <- H51 by omega.
  apply H46.
  eapply separated_trans; [|apply separated_sym; eassumption].
  repeat split; simpl; unfold x; Psatz.nia.
Qed.

Goal typed_matrix_mult_assoc_assert_8.
Hint matrix_mult_assoc,property.
Proof.
  intros.
  unfold x_1.
  rewrite Z.mul_comm.
  rewrite H56, H54 by omega.
  eapply Axiomatic1.Q_sum_assoc; try omega; eauto.
Qed.

Goal typed_matrix_mult_assoc_assert_9.
Hint matrix_mult_assoc,property.
Proof.
  intros.
  replace (t_3 .[ shift_sint32 a_4 (i_1 + i * i_2)])
     with (t_2 .[ shift_sint32 a_4 (i_1 + i * i_2)]).
  rewrite Z.mul_comm. rewrite H51 by omega.
  apply Axiomatic1.Q_sum_only_read; try omega.
  eapply Axiomatic1.Q_matrix_eq_trans.
  eassumption.
(* --------------------------------------
  
From 'typed_matrix_mult_assoc_assert_2': 
  intros. symmetry.
  apply H40.
  eapply separated_trans; [|apply separated_sym; eassumption].
  repeat split; simpl; unfold x; Psatz.nia.
*)
(* --------------------------------------
  
From 'typed_matrix_mult_assoc_assert_8': 
  intros.
  unfold x_1.
  rewrite Z.mul_comm.
  rewrite H56, H54 by omega.
  eapply Axiomatic1.Q_sum_assoc; try omega; eauto.
*)
(* --------------------------------------
  
From 'typed_matrix_mult_assoc_assert_5': 
(* auto with zarith. *)
*)
Qed.

Goal typed_matrix_mult_assoc_call_matrix_mult_pre_5_4.
Hint matrix_mult_assoc,precond-matrix_mult.
Proof.
(* auto with zarith. *)
Qed.

Goal typed_matrix_mult_loop_assign_part3.
Hint *,c,i,loop-assigns,matrix_mult,part-2.
Proof.
  intros.
  repeat split; simpl; Psatz.nia.
Qed.

Goal typed_matrix_mult_loop_inv_2_preserved.
Hint matrix_mult,preserved.
Proof.
  intros.
  assert (i = i_1) by omega. subst i_1.
  apply Zle_lt_or_eq in H6.
  destruct H6.
  - replace (L_sum t_3 a_2 a_1 i i_4 i_3 i) with (L_sum t_2 a_2 a_1 i i_4 i_3 i).
    rewrite <- H26 by omega.
    replace (i_4*i) with (i*i_4) by ring.
    symmetry.
    apply H24.
    do 4 right. simpl. unfold x_1. Psatz.nia.
    apply Axiomatic1.Q_sum_only_read; try Psatz.nia.
    + unfold P_matrix_eq. intros. symmetry. apply H24.
      eapply separated_trans;
        [|apply separated_sym;
          eapply separated_trans; [|apply separated_sym]].
      3: apply H21.
      repeat split; unfold x; simpl; Psatz.nia.
      repeat split; unfold x_1, x; simpl; Psatz.nia.
    + unfold P_matrix_eq. intros. symmetry. apply H24.
      eapply separated_trans;
        [|apply separated_sym;
          eapply separated_trans; [|apply separated_sym]].
      3: apply H22.
      repeat split; unfold x; simpl; Psatz.nia.
      repeat split; unfold x_1, x; simpl; Psatz.nia.
  - subst i_4.
    apply H25; omega.
Qed.

Goal typed_matrix_mult_loop_inv_4_preserved.
Hint matrix_mult,preserved.
Proof.
  intros.
  assert (i_1 = i_2) by omega. subst i_2.
  unfold m.
  apply Zle_lt_or_eq in H8.
  destruct H8.
  - rewrite access_update_neq.
    + rewrite H29 by omega.
      apply Axiomatic1.Q_sum_only_read; try omega.
      * unfold P_matrix_eq; intros.
        rewrite access_update_neq. reflexivity.
        eapply separated_1.
        assert (a = a_5).
        { unfold a_5. unfold shift_sint32, shift.
          replace (offset a+0) with (offset a) by ring.
          destruct a; reflexivity.
        }
        assert (a_1 = a_3).
        { unfold a_3. unfold shift_sint32, shift.
          replace (offset a_1+0) with (offset a_1) by ring.
          destruct a_1; reflexivity.
        }
        rewrite H33, H34 in *.
        apply separated_sym. eassumption.
        unfold x_2, x_1; simpl; Psatz.nia.
        unfold x_1; Psatz.nia.
      * unfold P_matrix_eq; intros.
        rewrite access_update_neq. reflexivity.
        eapply separated_1.
        assert (a = a_5).
        { unfold a_5. unfold shift_sint32, shift.
          replace (offset a+0) with (offset a) by ring.
          destruct a; reflexivity.
        }
        assert (a_2 = a_4).
        { unfold a_4. unfold shift_sint32, shift.
          replace (offset a_2+0) with (offset a_2) by ring.
          destruct a_2; reflexivity.
        }
        rewrite H33, H34 in *.
        apply separated_sym. eassumption.
        unfold x_2, x_1; simpl; Psatz.nia.
        unfold x_1; Psatz.nia.
    + intros contra. unfold x_2 in contra. inversion contra.
      Psatz.nia.
  - subst i_4. rewrite access_update. rewrite <- H at 1.
    apply Axiomatic1.Q_sum_only_read; try omega.
    + unfold P_matrix_eq; intros.
      rewrite 2!access_update_neq; [reflexivity| |].
      * eapply separated_1.
        assert (a = a_5).
        { unfold a_5. unfold shift_sint32, shift.
          replace (offset a+0) with (offset a) by ring.
          destruct a; reflexivity.
        }
        assert (a_1 = a_3).
        { unfold a_3. unfold shift_sint32, shift.
          replace (offset a_1+0) with (offset a_1) by ring.
          destruct a_1; reflexivity.
        }
        rewrite H32, H33 in *.
        apply separated_sym. eassumption.
        unfold x, x_1; simpl; Psatz.nia.
        unfold x_1; Psatz.nia.
      * eapply separated_1.
        assert (a = a_5).
        { unfold a_5. unfold shift_sint32, shift.
          replace (offset a+0) with (offset a) by ring.
          destruct a; reflexivity.
        }
        assert (a_1 = a_3).
        { unfold a_3. unfold shift_sint32, shift.
          replace (offset a_1+0) with (offset a_1) by ring.
          destruct a_1; reflexivity.
        }
        rewrite H32, H33 in *.
        apply separated_sym. eassumption.
        unfold x_2, x_1; simpl; Psatz.nia.
        unfold x_1; Psatz.nia.
    + unfold P_matrix_eq; intros.
      rewrite 2!access_update_neq; [reflexivity| |].
      * eapply separated_1.
        assert (a = a_5).
        { unfold a_5. unfold shift_sint32, shift.
          replace (offset a+0) with (offset a) by ring.
          destruct a; reflexivity.
        }
        assert (a_2 = a_4).
        { unfold a_4. unfold shift_sint32, shift.
          replace (offset a_2+0) with (offset a_2) by ring.
          destruct a_2; reflexivity.
        }
        rewrite H32, H33 in *.
        apply separated_sym. eassumption.
        unfold x, x_1; simpl; Psatz.nia.
        unfold x_1; Psatz.nia.
      * eapply separated_1.
        assert (a = a_5).
        { unfold a_5. unfold shift_sint32, shift.
          replace (offset a+0) with (offset a) by ring.
          destruct a; reflexivity.
        }
        assert (a_2 = a_4).
        { unfold a_4. unfold shift_sint32, shift.
          replace (offset a_2+0) with (offset a_2) by ring.
          destruct a_2; reflexivity.
        }
        rewrite H32, H33 in *.
        apply separated_sym. eassumption.
        unfold x_2, x_1; simpl; Psatz.nia.
        unfold x_1; Psatz.nia.

(* --------------------------------------
  
From 'typed_matrix_mult_loop_inv_2_preserved': 
  intros.
  assert (i = i_1) by omega. subst i_1.
  apply Zle_lt_or_eq in H6.
  destruct H6.
  - replace (L_sum t_3 a_2 a_1 i i_4 i_3 i) with (L_sum t_2 a_2 a_1 i i_4 i_3 i).
    rewrite <- H26 by omega.
    replace (i_4*i) with (i*i_4) by ring.
    symmetry.
    apply H24.
    do 4 right. simpl. unfold x_1. Psatz.nia.
    apply Axiomatic1.Q_sum_only_read; try Psatz.nia.
    + unfold P_matrix_eq. intros. symmetry. apply H24.
      eapply separated_trans;
        [|apply separated_sym;
          eapply separated_trans; [|apply separated_sym]].
      3: apply H21.
      repeat split; unfold x; simpl; Psatz.nia.
      repeat split; unfold x_1, x; simpl; Psatz.nia.
    + unfold P_matrix_eq. intros. symmetry. apply H24.
      eapply separated_trans;
        [|apply separated_sym;
          eapply separated_trans; [|apply separated_sym]].
      3: apply H22.
      repeat split; unfold x; simpl; Psatz.nia.
      repeat split; unfold x_1, x; simpl; Psatz.nia.
  - subst i_4.
    apply H25; omega.
*)
Qed.

Goal typed_matrix_mult_loop_inv_6_preserved.
Hint matrix_mult,preserved.
Proof.
  intros.
(* --------------------------------------
  
From 'typed_matrix_mult_loop_inv_2_preserved': 
  intros.
  assert (i = i_1) by omega. subst i_1.
  apply Zle_lt_or_eq in H6.
  destruct H6.
  - replace (L_sum t_3 a_2 a_1 i i_4 i_3 i) with (L_sum t_2 a_2 a_1 i i_4 i_3 i).
    rewrite <- H26 by omega.
    replace (i_4*i) with (i*i_4) by ring.
    symmetry.
    apply H24.
    do 4 right. simpl. unfold x_1. Psatz.nia.
    apply Axiomatic1.Q_sum_only_read; try Psatz.nia.
    + unfold P_matrix_eq. intros. symmetry. apply H24.
      eapply separated_trans;
        [|apply separated_sym;
          eapply separated_trans; [|apply separated_sym]].
      3: apply H21.
      repeat split; unfold x; simpl; Psatz.nia.
      repeat split; unfold x_1, x; simpl; Psatz.nia.
    + unfold P_matrix_eq. intros. symmetry. apply H24.
      eapply separated_trans;
        [|apply separated_sym;
          eapply separated_trans; [|apply separated_sym]].
      3: apply H22.
      repeat split; unfold x; simpl; Psatz.nia.
      repeat split; unfold x_1, x; simpl; Psatz.nia.
  - subst i_4.
    apply H25; omega.
*)
(* --------------------------------------
  
From 'typed_matrix_mult_loop_inv_4_preserved': 
  intros.
  assert (i_1 = i_2) by omega. subst i_2.
  unfold m.
  apply Zle_lt_or_eq in H8.
  destruct H8.
  - rewrite access_update_neq.
    + rewrite H29 by omega.
      apply Axiomatic1.Q_sum_only_read; try omega.
      * unfold P_matrix_eq; intros.
        rewrite access_update_neq. reflexivity.
        eapply separated_1.
        assert (a = a_5).
        { unfold a_5. unfold shift_sint32, shift.
          replace (offset a+0) with (offset a) by ring.
          destruct a; reflexivity.
        }
        assert (a_1 = a_3).
        { unfold a_3. unfold shift_sint32, shift.
          replace (offset a_1+0) with (offset a_1) by ring.
          destruct a_1; reflexivity.
        }
        rewrite H33, H34 in *.
        apply separated_sym. eassumption.
        unfold x_2, x_1; simpl; Psatz.nia.
        unfold x_1; Psatz.nia.
      * unfold P_matrix_eq; intros.
        rewrite access_update_neq. reflexivity.
        eapply separated_1.
        assert (a = a_5).
        { unfold a_5. unfold shift_sint32, shift.
          replace (offset a+0) with (offset a) by ring.
          destruct a; reflexivity.
        }
        assert (a_2 = a_4).
        { unfold a_4. unfold shift_sint32, shift.
          replace (offset a_2+0) with (offset a_2) by ring.
          destruct a_2; reflexivity.
        }
        rewrite H33, H34 in *.
        apply separated_sym. eassumption.
        unfold x_2, x_1; simpl; Psatz.nia.
        unfold x_1; Psatz.nia.
    + intros contra. unfold x_2 in contra. inversion contra.
      Psatz.nia.
  - subst i_4. rewrite access_update. rewrite <- H at 1.
    apply Axiomatic1.Q_sum_only_read; try omega.
    + unfold P_matrix_eq; intros.
      rewrite 2!access_update_neq; [reflexivity| |].
      * eapply separated_1.
        assert (a = a_5).
        { unfold a_5. unfold shift_sint32, shift.
          replace (offset a+0) with (offset a) by ring.
          destruct a; reflexivity.
        }
        assert (a_1 = a_3).
        { unfold a_3. unfold shift_sint32, shift.
          replace (offset a_1+0) with (offset a_1) by ring.
          destruct a_1; reflexivity.
        }
        rewrite H32, H33 in *.
        apply separated_sym. eassumption.
        unfold x, x_1; simpl; Psatz.nia.
        unfold x_1; Psatz.nia.
      * eapply separated_1.
        assert (a = a_5).
        { unfold a_5. unfold shift_sint32, shift.
          replace (offset a+0) with (offset a) by ring.
          destruct a; reflexivity.
        }
        assert (a_1 = a_3).
        { unfold a_3. unfold shift_sint32, shift.
          replace (offset a_1+0) with (offset a_1) by ring.
          destruct a_1; reflexivity.
        }
        rewrite H32, H33 in *.
        apply separated_sym. eassumption.
        unfold x_2, x_1; simpl; Psatz.nia.
        unfold x_1; Psatz.nia.
    + unfold P_matrix_eq; intros.
      rewrite 2!access_update_neq; [reflexivity| |].
      * eapply separated_1.
        assert (a = a_5).
        { unfold a_5. unfold shift_sint32, shift.
          replace (offset a+0) with (offset a) by ring.
          destruct a; reflexivity.
        }
        assert (a_2 = a_4).
        { unfold a_4. unfold shift_sint32, shift.
          replace (offset a_2+0) with (offset a_2) by ring.
          destruct a_2; reflexivity.
        }
        rewrite H32, H33 in *.
        apply separated_sym. eassumption.
        unfold x, x_1; simpl; Psatz.nia.
        unfold x_1; Psatz.nia.
      * eapply separated_1.
        assert (a = a_5).
        { unfold a_5. unfold shift_sint32, shift.
          replace (offset a+0) with (offset a) by ring.
          destruct a; reflexivity.
        }
        assert (a_2 = a_4).
        { unfold a_4. unfold shift_sint32, shift.
          replace (offset a_2+0) with (offset a_2) by ring.
          destruct a_2; reflexivity.
        }
        rewrite H32, H33 in *.
        apply separated_sym. eassumption.
        unfold x_2, x_1; simpl; Psatz.nia.
        unfold x_1; Psatz.nia.

(* --------------------------------------
  
From 'typed_matrix_mult_loop_inv_2_preserved': 
  intros.
  assert (i = i_1) by omega. subst i_1.
  apply Zle_lt_or_eq in H6.
  destruct H6.
  - replace (L_sum t_3 a_2 a_1 i i_4 i_3 i) with (L_sum t_2 a_2 a_1 i i_4 i_3 i).
    rewrite <- H26 by omega.
    replace (i_4*i) with (i*i_4) by ring.
    symmetry.
    apply H24.
    do 4 right. simpl. unfold x_1. Psatz.nia.
    apply Axiomatic1.Q_sum_only_read; try Psatz.nia.
    + unfold P_matrix_eq. intros. symmetry. apply H24.
      eapply separated_trans;
        [|apply separated_sym;
          eapply separated_trans; [|apply separated_sym]].
      3: apply H21.
      repeat split; unfold x; simpl; Psatz.nia.
      repeat split; unfold x_1, x; simpl; Psatz.nia.
    + unfold P_matrix_eq. intros. symmetry. apply H24.
      eapply separated_trans;
        [|apply separated_sym;
          eapply separated_trans; [|apply separated_sym]].
      3: apply H22.
      repeat split; unfold x; simpl; Psatz.nia.
      repeat split; unfold x_1, x; simpl; Psatz.nia.
  - subst i_4.
    apply H25; omega.
*)
*)
Qed.


