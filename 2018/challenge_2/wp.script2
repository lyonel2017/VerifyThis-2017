(* Generated by Frama-C WP *)

Goal typed_rouge_counting_loop_inv_bounds_established.
Hint bounds,counting,established.
Proof.
  intros. omega.
Qed.

Goal typed_rouge_counting_loop_inv_bounds_preserved.
Hint bounds,counting,preserved.
Proof.
  intros. omega.
Qed.

Goal typed_rouge_counting_loop_inv_main_inner_established.
Hint counting,established,main_inner.
Proof.
  intros. apply A_Sum.Q_sum1; reflexivity.
Qed.

Goal typed_rouge_counting_loop_inv_main_inner_preserved.
Hint counting,main_inner,preserved.
Proof.
  intros. unfold x_2.
  rewrite <- A_Sum.Q_sum3 with (i_1:=i-i_1).
  unfold x_5.
  replace (i-i_1) with (1+(i-1-i_1)) by omega.
  rewrite <- A_Sum.Q_sum2.
  rewrite A_Sum.Q_sum1 with (i:=i-1-i_1).
  unfold x_6. unfold x_3.
  f_equal.
  f_equal. omega.
  unfold m.
  rewrite 2!access_update_neq.
  unfold a_1. rewrite Z.add_0_r. reflexivity.
  unfold a_2. unfold a_1. intros contra. inversion contra. omega.
  unfold a_2. unfold a_1. intros contra. inversion contra. unfold x_5 in H16. omega.
  reflexivity. reflexivity. unfold x_2. omega.
  unfold x_5. omega.
  unfold x_5. omega.
Qed.

Goal typed_rouge_counting_loop_inv_main_outer_established.
Hint counting,established,main_outer.
Proof.
  intros.
  assert (i = 0 \/ i = 1 \/ i = 2 \/ i =3) by omega.
  decompose [or] H2; subst i;
    repeat (rewrite access_update || rewrite access_update_neq by discriminate);
    reflexivity.
Qed.

Goal typed_rouge_counting_loop_inv_main_outer_preserved.
Hint counting,main_outer,preserved.
Proof.
  (* repeat match goal with
  | |- ?H -> _ =>
     match H with
     | is_sint32 (1+_) => intros _
     | _ => intros ?
     end
  | |- _ => intro
  end. *)
  intros. assert (i_1= i) by omega. subst i_1.
  assert (i_2 < i \/ i_2 = i) by omega.
  destruct H14.
  - rewrite access_update_neq. auto. unfold a_2.
    intros contra. inversion contra. omega.
  - subst i_2. unfold a_2. rewrite access_update.
    unfold card. unfold filter.
    rewrite coq.test41.
    unfold x_1.
    rewrite H13 by omega.
    rewrite 2!Nat2Z.inj_add.
    rewrite Z.add_comm with (m:=Z.of_nat 1).
    rewrite Z.add_assoc. f_equal. f_equal.
    unfold card. unfold filter.
    rewrite Z2Nat.inj_sub. reflexivity. omega.
    replace 0 with (i-i) by omega.
    apply (Zlt_lower_bound_ind (fun l => l <= i ->
      L_sum (t_2 .[ shift_sint32 a i <- card (filter (i - 1))]) a_1 (i-l) (i - 3) =
      Z.of_nat (List.fold_left Nat.add
        (List.map (coq.g (Z.to_nat i)) (List.seq 3 (Z.to_nat l - 3))) 0%nat)) 3);
      try omega.
    intros.
    assert (3 = x0 \/ 3 < x0) by omega.
    destruct H17.
    subst x0.
    simpl. rewrite A_Sum.Q_sum1; reflexivity.
    rewrite <- A_Sum.Q_sum3 with (i_1:=i-x0+1).
    rewrite coq.seq_l.
    rewrite List.map_app.
    simpl.
    rewrite coq.fold_add_last_simpl.
    simpl.
    rewrite Nat2Z.inj_add.
    rewrite Z.add_comm.
    f_equal.
    replace (i-x0+1) with (1+(i-x0)) by omega.
    rewrite <- A_Sum.Q_sum2 by omega.
    rewrite A_Sum.Q_sum1 by omega.
    rewrite access_update_neq.
    rewrite Z.add_0_r. rewrite H13.
    unfold coq.g.
    apply Z2Nat.inj_le in H16 as ?; try omega.
    apply Z2Nat.inj_lt in H17 as ?; try omega.
    replace (Z.to_nat 3) with 3%nat in H19 by reflexivity.
    rewrite (proj2 (Nat.eqb_neq _ _)) by omega.
    rewrite (proj2 (Nat.leb_le _ _)) by omega.
    rewrite (proj2 (Nat.ltb_lt _ _)) by omega. simpl.
    unfold card, filter.
    f_equal. f_equal. f_equal.
    rewrite Z2Nat.inj_sub. omega.
    omega. omega. omega.
    intros contra. inversion contra. omega.
    replace (i-x0+1) with (i - (x0-1)) by omega.
    rewrite H14.
    f_equal. f_equal. f_equal. f_equal.
    rewrite Z2Nat.inj_sub. unfold Z.to_nat at 2, Pos.to_nat. simpl.
    omega. omega. omega. omega.
    apply Z2Nat.inj_lt in H17 as HH;
      try replace (Z.to_nat 3) with 3%nat in HH by reflexivity; omega.
    omega. omega. omega.
    apply Z2Nat.inj_le in H4 as HH;
      try replace (Z.to_nat 4) with 4%nat in HH by reflexivity; omega.
Qed.

Goal typed_rouge_counting_post_main_post.
Hint counting,default,main_post,property.
Proof.
  intros. apply H6; omega.
Qed.

Goal typed_rouge_lemma_sum3.
Hint property,sum3.
Proof.
  intros.
  apply Zlt_lower_bound_ind with
  (P:= fun k => L_sum t a i_1 k + L_sum t a i_2 i_1 = L_sum t a i_2 k)(z := i_1).
  intros.
  assert (h:(i_1 = x \/ i_1 < x)) by omega.
  destruct h.
  - rewrite H4.
    rewrite Q_sum1.
    rewrite Int.Unit_def_l.
    reflexivity.
    omega.
  - replace x with ((x-1)+1) by omega.
    generalize (H2 (x-1)).
    intros.
    replace (x-1+1) with (1+(x-1)) by omega.
    rewrite <- Q_sum2.
    rewrite <- Q_sum2.
    rewrite <- H5.
    rewrite Z.add_assoc.
    reflexivity.
    all:try omega.
  - assumption.
Qed.

Goal typed_rouge_lemma_sum_4.
Hint property,sum_4.
Proof.
  intros i j M1 M2 t.
  assert (h: i > j \/ i <= j) by omega.
  destruct h.
  - intros hyp.
    rewrite Q_sum1.
    rewrite Q_sum1.
    reflexivity.
    omega.
    omega.
  - generalize H.
    apply Zlt_lower_bound_ind with
    (P:= fun j => (i <= j) -> (forall k_0 : int,
    k_0 < j -> i <= k_0->
    M1 .[shift_sint32 t k_0 ] =
    M2 .[shift_sint32 t k_0 ]) ->
    L_sum M1 t i j = L_sum M2 t i j)
    (z:=i).
    intros.
    assert (h:(i = x \/ i < x)) by omega.
    destruct h.
     * rewrite H4.
       rewrite Q_sum1.
       rewrite Q_sum1.
       reflexivity.
       omega.
       omega.
     * assert (h:(i = x \/ i < x)) by omega.
       destruct h.
       + rewrite H5.
         rewrite Q_sum1.
         rewrite Q_sum1.
         reflexivity.
         omega.
         omega.
       +  replace x with (1+(x-1)) by omega.
          rewrite <- Q_sum2.
          rewrite <- Q_sum2.
          rewrite  (H3 (x-1)).
          rewrite H0.
          reflexivity.
          all:auto with zarith.
    * assumption.
Qed.


